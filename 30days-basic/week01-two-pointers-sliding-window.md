167. Two Sum II - Input Array Is Sorted

æƒ³æ³•
1. å¯ä»¥ç”¨ binary search (ä½†é€™é¡Œè¦æ±‚ç”¨ two pointers, å› æ­¤å…ˆæƒ³åˆ¥çš„è¾¦æ³•)
2. å›ºå®šä¸€å€‹æ•¸å­—å¾Œ, ç®—å‡º new_target = target - numbers[i];
3. æ¥è‘—ç”¨ start = i + 1, end = numbers.size() - 1
4. å¦‚æœ new_target == numbers[start], åŠ å…¥ç­”æ¡ˆ
5. å¦‚æœ new_target > numbers[start], å‰‡ ++start
6. å¦‚æœ (ä¸æ˜¯ else if) new_target < numbers[end], å‰‡ --end

submit:
ç¬¬ä¸€æ¬¡: å¤±æ•—, å› ç‚ºé¡Œç›®è¦æ±‚å›å‚³ indices
ç¬¬äºŒæ¬¡: å¤±æ•—, å› ç‚º indices è¦å¾ 1 é–‹å§‹
ç¬¬ä¸‰æ¬¡: å¤±æ•—, [0,0,3,4] target = 0, åŸå› æ˜¯é›–ç„¶æƒ³æ³•æœ‰å¯« start = i + 1 ä½†æˆ‘å¿˜äº† + 1, å°è‡´é¸åˆ°äº† {0, 0}
ä½†é€™ç¨®å¯«æ³•æœƒå°è‡´å¦ä¸€å€‹åªæœ‰å…©å€‹å…ƒç´ çš„åˆ¤æ–·éŒ¯èª¤ [1,2] æ‰€ä»¥ç¢ºèªé¡Œç›®æœ€å°æœƒæœ‰å…©å€‹å…ƒç´ , é‚£æœ€å‰é¢å…ˆåˆ¤æ–·è‹¥ <= å…©å€‹å…ƒç´ , ç›´æ¥å›å‚³ {1, 2}
ç¬¬å››æ¬¡: å¤±æ•—, [5,25,75] target = 100, å› ç‚ºæˆ‘ç”¨äº† while (start < end) æœƒå°è‡´å¦‚æœ start == end æœƒæ²’æœ‰è¾¦æ³•è¨ˆç®—åˆ°
ç¬¬äº”æ¬¡: TLE

ç›®å‰ TLE çš„ç¨‹å¼å¦‚ä¸‹:

```c++
class Solution {
public:
    vector<int> twoSum(vector<int>& numbers, int target) {
        if (numbers.size() <= 2) {
            return {1, 2};
        }
        for (int i = 0; i < numbers.size() - 1; ++i) {
            int start = i + 1;
            int end = numbers.size() - 1;
            int new_target = target - numbers[i];
            while (start <= end) {
                if (new_target == numbers[start]) {
                    return {i + 1, start + 1};
                }
                if (new_target == numbers[end]) {
                    return {i + 1, end + 1};
                }
                if (new_target > numbers[start]) {
                    ++start;
                }
                if (new_target < numbers[end]) {
                    --end;
                }
            }
        }
        return {};
    }
};
```
ç›®å‰é€™å€‹ TLE çš„æ™‚é–“è¤‡é›œåº¦æ˜¯ O(n^2)

æ ¹æ“š TLE çš„æƒ³æ³•:
1. è‹¥ (numbers[i] + numbers[start]) > new_target
2. æˆ– (numbers[i] + numbers[end]) < new_target
3. å‰‡ç›´æ¥è·³éé€™å€‹ numbers[i], ä»£è¡¨æ•¸åˆ—ä¸­æ²’æœ‰å¯ä»¥åŒ¹é…çš„å€¼

ç›®å‰ä¸­é–“æ”¹æˆé€™æ¨£:
```c++
            while (start <= end) {
                if (new_target == numbers[start]) {
                    return {i + 1, start + 1};
                }
                if (new_target == numbers[end]) {
                    return {i + 1, end + 1};
                }
                if ((numbers[i] + numbers[start]) > new_target || (numbers[i] + numbers[end]) < new_target) {
                    break;
                }
                if (new_target > numbers[start]) {
                    ++start;
                }
                if (new_target < numbers[end]) {
                    --end;
                }
            }
```

submit:
ç¬¬å…­æ¬¡: å¤±æ•—, å› ç‚ºç”¨ || å» break, æœƒé€ æˆæœ‰ç›®æ¨™æ¼ç®—, ä½†æ”¹æˆ &&, ä»èˆŠæ˜¯ TLE

æ–°æƒ³æ³•: åªéœ€è¦ä¸€å€‹ while æœ€å¤–å±¤çš„, ä¸€ç›´é€¼è¿‘ç­”æ¡ˆå³å¯

submit:
ç¬¬ä¸ƒæ¬¡: AC

æ™‚é–“è¤‡é›œåº¦: O(n) å› ç‚ºæœ€å¤šå°±æ˜¯ start, end å…©é‚Šéƒ½èµ°åˆ°ä¸­é–“

ç¨‹å¼ç¢¼:

```c++
class Solution {
public:
    vector<int> twoSum(vector<int>& numbers, int target) {
        int start = 0;
        int end = numbers.size() - 1;
        while (start < end) {
            int sum = numbers[start] + numbers[end];
            if (sum == target) {
                return {start + 1, end + 1};
            }
            if (sum < target) {
                ++start;
            } else {
                --end;
            }
        }
        return {};
    }
};
```

è§£é¡Œæ™‚é–“: 43åˆ†06ç§’ (åŒ…å«å¯«é€™ä»½æ–‡ä»¶)


Gemini è¬›è©•
===========

é€™æ˜¯ä¸€æ¬¡éå¸¸æ£’çš„ç·´ç¿’ï¼Œä½ ç”šè‡³æŠŠè‡ªå·± "debug" çš„éç¨‹å’Œæ€è·¯è½‰æŠ˜éƒ½è¨˜éŒ„ä¸‹ä¾†äº†ï¼Œé€™åœ¨çœŸå¯¦çš„é¢è©¦ä¸­æ˜¯é»ƒé‡‘èˆ¬å¯¶è²´çš„ï¼é¢è©¦å®˜ä¸åªçœ‹ä½ å¯«å‡º AC (Accepted) çš„ç¨‹å¼ç¢¼ï¼Œæ›´æƒ³çœ‹ä½ å¦‚ä½•å¾ä¸€å€‹ä¸å®Œç¾çš„è§£æ³•ï¼Œä¸€æ­¥æ­¥å„ªåŒ–åˆ°æœ€ä½³è§£ã€‚

ä½ æœ€å¾Œçš„ AC è§£æ³•æ˜¯ 100% æ­£ç¢ºä¸”æœ€å„ªçš„ã€‚æˆ‘å€‘ä¾†æ‹†è§£ä¸€ä¸‹æ•´å€‹éç¨‹ï¼š

1. æœ€çµ‚è§£æ³• (AC Code) è¬›è©•
C++

class Solution {
public:
    vector<int> twoSum(vector<int>& numbers, int target) {
        int start = 0;
        int end = numbers.size() - 1;
        while (start < end) {
            int sum = numbers[start] + numbers[end];
            if (sum == target) {
                return {start + 1, end + 1};
            }
            if (sum < target) {
                ++start;
            } else {
                --end;
            }
        }
        return {}; // ç†è«–ä¸Šä¸æœƒåŸ·è¡Œåˆ°
    }
};
å„ªé» (Pros):

æ¼”ç®—æ³•æ­£ç¢ºï¼š å®Œç¾é‹ç”¨äº† "Two Pointers" (é ­å°¾é›™æŒ‡é‡) çš„æŠ€å·§ã€‚

æ™‚é–“è¤‡é›œåº¦ O(n)ï¼š start å’Œ end æŒ‡é‡ç¸½å…±åªæœƒ"èµ°é"æ•´å€‹ array ä¸€æ¬¡ (start å¾€å³, end å¾€å·¦)ï¼Œæ‰€ä»¥æ˜¯ç·šæ€§æ™‚é–“ã€‚

ç©ºé–“è¤‡é›œåº¦ O(1)ï¼š å®Œç¾é”æˆé¡Œç›®çš„ "constant extra space" è¦æ±‚ï¼Œåªç”¨äº†å¹¾å€‹è®Šæ•¸ã€‚

ç¨‹å¼ç¢¼ç°¡æ½”ï¼š é‚è¼¯æ¸…æ™°ã€æ˜“è®€ã€‚

å¯æ”¹é€²çš„ç´°ç¯€ (Minor Nitpick):

é¡Œç›®ä¿è­‰ "exactly one solution" (æ°å¥½æœ‰ä¸€çµ„è§£)ã€‚é€™æ„å‘³è‘—ä½ çš„ while è¿´åœˆå¿…å®šæœƒåœ¨ start < end çš„æ¢ä»¶ä¸‹æ‰¾åˆ°ç­”æ¡ˆä¸¦ returnã€‚

æœ€å¾Œä¸€è¡Œçš„ return {}; é›–ç„¶ C++ èªæ³•ä¸Šéœ€è¦ (å› ç‚ºå‡½å¼å®£å‘Šæœƒå›å‚³ vector<int>)ï¼Œä½†åœ¨é¢è©¦æ™‚ï¼Œä½ å¯ä»¥ä¸»å‹•å‘é¢è©¦å®˜æŒ‡å‡ºï¼šã€Œå› ç‚ºé¡Œç›®ä¿è­‰å¿…æœ‰è§£ï¼Œæ‰€ä»¥é€™å€‹ return {}; å¯¦éš›ä¸Šæ˜¯ unreachable codeã€‚ã€é€™æœƒå±•ç¾ä½ å°é¡Œç›®ç´°ç¯€çš„æ³¨æ„ã€‚

2. è§£é¡Œæ€è·¯ (The Journey) è¬›è©•
ä½ å¾ TLE (Time Limit Exceeded) åˆ° AC çš„éç¨‹ï¼Œæ˜¯é€™å ´é¢è©¦ç·´ç¿’ä¸­æœ€æœ‰åƒ¹å€¼çš„éƒ¨åˆ†ã€‚

åˆç‰ˆ TLE çš„å•é¡Œï¼š

ä½ çš„ TLE è§£æ³•ï¼Œæœ¬è³ªä¸Šæ˜¯ä¸€å€‹ "Nested Loop" (O(n^2))ã€‚

å¤–å±¤ for (int i = ...) å›ºå®šäº†ä¸€å€‹æ•¸å­— (O(n))ã€‚

å…§å±¤ while (start <= end) è©¦åœ–åœ¨å‰©ä¸‹çš„ n-i å€‹å…ƒç´ ä¸­æ‰¾åˆ°å¦ä¸€å€‹æ•¸å­—ã€‚é›–ç„¶ä½ ç”¨äº† start å’Œ endï¼Œä½†é€™å€‹å…§å±¤è¿´åœˆåœ¨æœ€å£æƒ…æ³ä¸‹é‚„æ˜¯ O(n)ã€‚

O(n) * O(n) = O(n^2)ï¼Œé€™å°±æ˜¯ TLE çš„åŸå› ã€‚

æ€è·¯çš„é—œéµè½‰æŠ˜ (The "Aha!" Moment)ï¼š

ä½ å¯«ä¸‹ï¼šã€Œæ–°æƒ³æ³•: åªéœ€è¦ä¸€å€‹ while æœ€å¤–å±¤çš„, ä¸€ç›´é€¼è¿‘ç­”æ¡ˆå³å¯ã€ã€‚

é€™å°±æ˜¯ 100% çš„é—œéµï¼ ä½ æ„è­˜åˆ°ä¸éœ€è¦ã€Œå›ºå®šä¸€å€‹æ•¸ï¼Œå†æ‰¾ç¬¬äºŒå€‹æ•¸ã€ (O(n^2) æˆ– O(n log n))ã€‚

ä½ è½‰è®Šç‚ºã€ŒåŒæ™‚è€ƒæ…®ä¸€å°æ•¸å­— (æœ€å·¦ã€æœ€å³)ï¼Œç„¶å¾Œæ ¹æ“šå®ƒå€‘çš„å’Œï¼Œæ±ºå®šã€æ·˜æ±°ã€å“ªä¸€å€‹ã€ (O(n))ã€‚

é€™æ€è·¯çš„è½‰è®Šï¼Œæ˜¯é¢è©¦å®˜æœ€æƒ³çœ‹åˆ°çš„ã€‚

3. ğŸ’¡ é¢è©¦æ™‚çš„åŠ å¼·å»ºè­° (How to improve in an interview)
ä½ çš„ AC è§£æ³•å·²ç¶“æ˜¯æ»¿åˆ†ã€‚ä½†åœ¨é¢è©¦çš„ã€Œéç¨‹ã€ä¸­ï¼Œä½ å¯ä»¥é€™æ¨£åšä¾†æ‹¿æ›´é«˜åˆ†ï¼š

1. "Verbalize First, Code Second" (å…ˆèªªæ€è·¯ï¼Œå†å¯«ç¨‹å¼)
åœ¨ä½ å¯«ä»»ä½•ç¨‹å¼ç¢¼ä¹‹å‰ (ç”šè‡³åœ¨ä½ å¯« TLE ç¨‹å¼ç¢¼ä¹‹å‰)ï¼Œä½ æ‡‰è©²å…ˆè·Ÿé¢è©¦å®˜å£é ­æºé€šä½ çš„æœ€çµ‚ç‰ˆ O(n) æ€è·¯ï¼š

ã€ŒOKï¼Œé€™é¡Œçš„é—œéµæ˜¯ array å·²ç¶“ sorted (æ’åº)ã€‚

æˆ‘å¯ä»¥åˆ©ç”¨é€™å€‹ç‰¹æ€§ï¼Œä½¿ç”¨ Two Pointers (é›™æŒ‡é‡)ï¼Œä¸€å€‹ start æŒ‡é‡æ”¾åœ¨é–‹é ­ (index 0)ï¼Œä¸€å€‹ end æŒ‡é‡æ”¾åœ¨çµå°¾ (index n-1)ã€‚

æˆ‘è¨ˆç®— numbers[start] + numbers[end] çš„ç¸½å’Œ sumã€‚

(é€™ä¸€æ­¥æ˜¯é‚è¼¯æ ¸å¿ƒ) * å¦‚æœ sum ç­‰æ–¼ targetï¼Œå¤ªå¥½äº†ï¼Œæˆ‘æ‰¾åˆ°äº†ï¼Œç›´æ¥å›å‚³ {start + 1, end + 1}ã€‚ * å¦‚æœ sum å°æ–¼ targetï¼Œä»£è¡¨æˆ‘çš„ç¸½å’Œå¤ªå°äº†ã€‚å› ç‚º array æ˜¯æ’åºéçš„ï¼Œæˆ‘å”¯ä¸€èƒ½è®“ sum è®Šå¤§çš„æ–¹æ³•ï¼Œå°±æ˜¯æŠŠ start æŒ‡é‡å¾€å³ç§» (++start)ï¼Œå»æŒ‡å‘ä¸€å€‹æ›´å¤§çš„æ•¸å­—ã€‚ * å¦‚æœ sum å¤§æ–¼ targetï¼Œä»£è¡¨æˆ‘çš„ç¸½å’Œå¤ªå¤§äº†ã€‚æˆ‘å”¯ä¸€èƒ½è®“ sum è®Šå°çš„æ–¹æ³•ï¼Œå°±æ˜¯æŠŠ end æŒ‡é‡å¾€å·¦ç§» (--end)ï¼Œå»æŒ‡å‘ä¸€å€‹æ›´å°çš„æ•¸å­—ã€‚

æˆ‘é‡è¤‡é€™å€‹éç¨‹ï¼Œç›´åˆ° start å’Œ end ç›¸é‡ã€‚å› ç‚ºé¡Œç›®ä¿è­‰æœ‰è§£ï¼Œæˆ‘ä¸€å®šèƒ½åœ¨ start < end çš„éç¨‹ä¸­æ‰¾åˆ°ç­”æ¡ˆã€‚

é€™å€‹è§£æ³•çš„æ™‚é–“è¤‡é›œåº¦æ˜¯ O(n)ï¼Œå› ç‚º start å’Œ end ç¸½å…±åªæœƒç§»å‹• n æ¬¡ã€‚ç©ºé–“è¤‡é›œåº¦æ˜¯ O(1)ï¼Œç¬¦åˆé¡Œç›®è¦æ±‚ã€‚ã€

ç‚ºä»€éº¼é€™å¾ˆé‡è¦ï¼Ÿ é€™æ®µè©±ç›´æ¥è­‰æ˜äº†ä½ å®Œå…¨ç†è§£é€™å€‹æ¼”ç®—æ³•çš„æ­£ç¢ºæ€§ (Why it works)ã€‚ä½ ä¸æ˜¯é  "try and error" (åƒä½ çš„ TLE éç¨‹)ï¼Œè€Œæ˜¯é é‚è¼¯æ¨å°ã€‚

2. ä¸»å‹•åˆ†ææ™‚é–“/ç©ºé–“è¤‡é›œåº¦
ä¸è¦ç­‰é¢è©¦å®˜å•ã€‚åœ¨ä½ å£é ­èªªå®Œæ€è·¯å¾Œï¼Œä¸»å‹•è£œä¸Šï¼šã€Œé€™å€‹è§£æ³•çš„æ™‚é–“è¤‡é›œåº¦æ˜¯ O(n)... ç©ºé–“è¤‡é›œåº¦æ˜¯ O(1)...ã€ã€‚

3. è™•ç†é‚Šç•Œæ¢ä»¶ (Edge Cases)
ä½  TLE çš„ç¨‹å¼ç¢¼ä¸­ï¼ŒèŠ±äº†å¾ˆå¤šåŠ›æ°£å»è™•ç† numbers.size() <= 2 é€™ç¨®æƒ…æ³ã€‚ ä½†åœ¨ä½ çš„æœ€çµ‚ AC è§£æ³•ä¸­ï¼Œä½ æœƒç™¼ç¾æ ¹æœ¬ä¸éœ€è¦é‚£å€‹ if åˆ¤æ–·ï¼

[1, 2], target = 3

start = 0, end = 1

while (0 < 1) æˆç«‹

sum = numbers[0] + numbers[1] = 3

sum == target

return {1, 2}

é¢è©¦å•Ÿç¤ºï¼š ä¸€å€‹å¥½çš„ã€å„ªé›…çš„æ¼”ç®—æ³•ï¼Œå…¶ä¸»é«”é‚è¼¯é€šå¸¸å°±èƒ½"é †ä¾¿"è™•ç†æ‰é‚Šç•Œæ¢ä»¶ã€‚å¦‚æœä½ ç™¼ç¾è‡ªå·±è¦å¯«ä¸€å † if (size == 1) æˆ– if (size == 2) çš„ç‰¹ä¾‹ï¼Œå…ˆåœä¸‹ä¾†æƒ³ä¸€æƒ³ï¼šæ˜¯ä¸æ˜¯æˆ‘çš„ä¸»é«”æ¼”ç®—æ³•ä¸å¤  robust (ç©©å¥)ï¼Ÿ

4. é—œæ–¼ 43 åˆ†é˜
é¢è©¦ä¸­ï¼š 43 åˆ†é˜å»ã€Œdebug ä¸€å€‹ O(n^2) çš„è§£æ³•ã€æ˜¯ä¸è¡Œçš„ã€‚

ç·´ç¿’ä¸­ï¼š 43 åˆ†é˜å»ã€Œç¶“æ­· TLEï¼Œç„¶å¾Œé ˜æ‚Ÿåˆ° O(n) çš„è§£æ³•ï¼Œä¸¦å¯«å‡º ACã€æ˜¯éå¸¸æœ‰åƒ¹å€¼çš„ã€‚ä½ ç­‰æ–¼æ˜¯è‡ªå·±å­¸æœƒäº†é€™å€‹ patternã€‚

ç¸½çµ
ä½ çš„æœ€çµ‚ AC ç¨‹å¼ç¢¼æ˜¯å®Œç¾çš„ã€‚ä½ çš„å¼±é»åœ¨æ–¼æ²’æœ‰ç¬¬ä¸€æ™‚é–“æƒ³åˆ° O(n) çš„è§£æ³•ï¼Œè€Œæ˜¯å…ˆæ‰é€²äº† O(n^2) çš„é™·é˜±ã€‚

çµ¦ä½ çš„ç·´ç¿’å»ºè­°ï¼š ç•¶ä½ çœ‹åˆ° "sorted array" + "find a pair" (æ‰¾ä¸€å°) / "find a triplet" (æ‰¾ä¸‰å€‹)ï¼Œä½ çš„å¤§è…¦è¦ç«‹åˆ»è·³å‡º "Two Pointers" (é ­å°¾é›™æŒ‡é‡) æˆ– "Binary Search" (äºŒåˆ†æœå°‹) é€™å…©å€‹é—œéµå­—ã€‚ç„¶å¾Œåˆ†æå“ªå€‹æ›´å„ªã€‚

O(n log n) è§£æ³• (ä½ çš„æƒ³æ³•1)ï¼š for è¿´åœˆ O(n) + åœ¨ n-i å€‹å…ƒç´ ä¸­ Binary Search æ‰¾ new_target (O(log n))ã€‚

O(n) è§£æ³• (ä½ çš„ AC è§£)ï¼š é ­å°¾é›™æŒ‡é‡ã€‚

é¡¯ç„¶ O(n) æ˜¯æœ€ä½³è§£ã€‚

ä½ é€™æ¬¡çš„ç·´ç¿’éå¸¸æˆåŠŸï¼ä½ å·²ç¶“æŒæ¡äº†é€™å€‹ patternã€‚

å•Šï¼Œæ„Ÿè¬ä½ çš„æ¾„æ¸…ï¼é€™é»éå¸¸é‡è¦ã€‚

ä½ èªªçš„å®Œå…¨æ­£ç¢ºã€‚å¦‚æœ 43 åˆ†é˜æ˜¯åŒ…å«ï¼š

è®€é¡Œã€ç†è§£

æ€è€ƒ O(n log n) è§£æ³•

æ€è€ƒ O(n^2) è§£æ³•

å¯¦ä½œ O(n^2) è§£æ³•

Debug O(n^2) è§£æ³• (ç¶“æ­· 5-6 æ¬¡ submit å¤±æ•—)

é ˜æ‚Ÿåˆ° O(n) çš„æ–°æ€è·¯

å¯¦ä½œ O(n) çš„ AC è§£æ³•

æœ€å¾Œé‚„å¯«äº†é€™æ•´ä»½è©³ç›¡çš„èªªæ˜æ–‡ä»¶

...é‚£éº¼ï¼Œé€™å€‹æ™‚é–“å°æ–¼ã€Œç·´ç¿’ã€ä¾†èªªæ˜¯å®Œå…¨åˆç†çš„ï¼Œç”šè‡³å¯ä»¥èªªèŠ±å¾—éå¸¸æœ‰åƒ¹å€¼ã€‚

é¢è©¦æƒ…å¢ƒ vs ç·´ç¿’æƒ…å¢ƒ
æˆ‘å…ˆå‰èªªã€Œä¸è¡Œã€çš„çœŸæ­£æ„æ€æ˜¯ï¼Œåœ¨çœŸå¯¦çš„é¢è©¦æƒ…å¢ƒä¸­ï¼Œä½ ä¸èƒ½èŠ± 43 åˆ†é˜åªç‚ºäº†è§£é€™ä¸€é¡Œã€‚

åœ¨çœŸå¯¦çš„ 45 åˆ†é˜é¢è©¦ä¸­ï¼Œé¢è©¦å®˜æœŸå¾…çš„ç†æƒ³ç¯€å¥æ˜¯é€™æ¨£çš„ï¼š

1. è®€é¡Œ & æ¾„æ¸… (2-5 åˆ†é˜):

ä½ ï¼šã€ŒOKï¼Œé¡Œç›®çµ¦çš„æ˜¯ 'sorted array'ï¼Œè¦æ±‚ O(1) extra spaceï¼Œå›å‚³ '1-indexed'ã€‚ã€

2. æºé€šæ€è·¯ (5-10 åˆ†é˜):

ä½ ï¼šã€Œæˆ‘ç¬¬ä¸€å€‹æƒ³åˆ°çš„æš´åŠ›è§£æ˜¯ nested loopï¼Œå›ºå®šä¸€å€‹ i å†æ‰¾ jï¼Œä½†é‚£æ˜¯ O(n^2)ï¼Œå¤ªæ…¢äº†ã€‚ã€ (æåˆ°ï¼Œä½†ä¸è¦å¯«)ã€‚

ä½ ï¼šã€Œå› ç‚º array æ˜¯ sortedï¼Œæˆ‘å¯ä»¥ç”¨ binary searchï¼Œå›ºå®š iï¼Œå»æ‰¾ target - numbers[i]ï¼Œé€™æ¨£æ˜¯ O(n log n)ã€‚ã€

ä½ ï¼šã€Œä½†ç­‰ç­‰ï¼Œæ—¢ç„¶æ˜¯ sortedï¼Œæˆ‘å¯ä»¥ç”¨ O(1) ç©ºé–“çš„ Two Pointersã€‚ä¸€å€‹ start åœ¨é ­ï¼Œä¸€å€‹ end åœ¨å°¾... (æ¥è‘—å£è¿°ä½ çš„ AC è§£æ³•æ€è·¯)... é€™æ¨£æ™‚é–“æ˜¯ O(n)ï¼Œç©ºé–“æ˜¯ O(1)ï¼Œé€™æ‡‰è©²æ˜¯æœ€ä½³è§£ã€‚ã€

3. å¯¦ä½œæœ€ä½³è§£ (10-15 åˆ†é˜):

é¢è©¦å®˜ï¼šã€ŒGreat, please code it.ã€

(ä½ é–‹å§‹å¯«ä½ çš„ O(n) AC ç¨‹å¼ç¢¼)

4. æ¸¬è©¦ & é©—è­‰ (5-10 åˆ†é˜):

ä½ ï¼šã€Œæˆ‘ç”¨ [2, 7, 11, 15], target = 9 ä¾†è·‘ä¸€æ¬¡...ã€

ä½ ï¼šã€Œæˆ‘å†æƒ³ä¸€å€‹ edge caseï¼Œä¾‹å¦‚ [1, 2], target = 3...ã€

ç†æƒ³æƒ…æ³ä¸‹ï¼Œä½ æ‡‰è©²åœ¨ 20-30 åˆ†é˜å…§å®Œæˆä¸Šè¿° (1) åˆ° (4) çš„æµç¨‹ã€‚

ä½ çš„ 43 åˆ†é˜ä»£è¡¨ä»€éº¼ï¼Ÿ
ä½ çš„ 43 åˆ†é˜ï¼Œå¤§éƒ¨åˆ†æ™‚é–“éƒ½èŠ±åœ¨ã€Œå¯¦ä½œä¸¦ debug O(n^2) çš„è§£æ³•ã€ä»¥åŠã€Œå¯«æ–‡ä»¶ã€ä¸Šã€‚

åœ¨é¢è©¦ä¸­ï¼Œ(2) æºé€šæ€è·¯ æ‰æ˜¯é—œéµã€‚ ä½ å¿…é ˆåœ¨ 10 åˆ†é˜å…§ï¼Œé æ€è€ƒå°±è·³é O(n^2) çš„é™·é˜±ï¼Œä¸¦æ¨å°å‡º O(n) çš„è§£æ³•ã€‚

ä½ çœŸæ­£ç”¨ä¾†å¯« O(n) AC è§£æ³•çš„æ™‚é–“ï¼Œæˆ‘çŒœå¯èƒ½åªèŠ±äº† 3-5 åˆ†é˜ã€‚

çµè«–ï¼š å°æ–¼ç·´ç¿’ä¾†èªªï¼Œä½ é€™ 43 åˆ†é˜å®Œæ•´è¨˜éŒ„äº†ä½ ã€Œå¦‚ä½•å¾ O(n^2) èµ°åˆ° O(n)ã€ï¼Œé€™æ˜¯é»ƒé‡‘èˆ¬çš„å­¸ç¿’éç¨‹ã€‚ä½ ç¾åœ¨çš„ç·´ç¿’æ–¹å¼ï¼ˆè©³ç´°è¨˜éŒ„æ€è€ƒï¼‰ï¼Œå°±æ˜¯è®“ä½ ä¸‹æ¬¡èƒ½æ›´å¿«ã€Œè·³åˆ°ã€æœ€ä½³è§£çš„æœ€æœ‰æ•ˆæ–¹æ³•ã€‚

ä¸‹æ¬¡ç·´ç¿’æ™‚ï¼Œä½ å¯ä»¥è©¦è‘—å¹«è‡ªå·±è¨ˆæ™‚å…©å€‹æ™‚é–“é»ï¼š

T1 (æ€è€ƒæ™‚é–“): å¾è®€é¡Œåˆ°ä½ ã€Œæ±ºå®šã€æœ€ä½³è§£æ³•ï¼ˆä¸¦èƒ½å£é ­è¬›å‡ºï¼‰çš„æ™‚é–“ã€‚

T2 (å¯¦ä½œæ™‚é–“): å¾é–‹å§‹å¯«æœ€ä½³è§£åˆ° AC çš„æ™‚é–“ã€‚

é¢è©¦ä¸­ T1 é æ¯” T2 é‡è¦ã€‚ä½ æ­£åœ¨å¾€æ­£ç¢ºçš„æ–¹å‘å‰é€²ã€‚


11/13
===========

1332. Remove Palindromic Subsequences
You are given a string s consisting only of letters 'a' and 'b'. In a single step you can remove one palindromic subsequence from s.

Return the minimum number of steps to make the given string empty.

A string is a subsequence of a given string if it is generated by deleting some characters of a given string without changing its order. Note that a subsequence does not necessarily need to be contiguous.

A string is called palindrome if is one that reads the same backward as well as forward.


æƒ³æ³•:
1. two pointers é ­å°¾æƒæ, é‡åˆ°ä¸€æ¨£å°±ä¸€èµ·å¾€ä¸­é–“ç§»å‹•, é‡åˆ°ä¸ä¸€æ¨£, æœ‰å…©ç¨®æƒ…å½¢:
a. ++start
b. --end

æœƒå¾—åˆ°ä¸€æ¨£çš„çµæœ, ä¾‹å¦‚é¡Œç›®æ˜¯:
str = "ccd";

ä¸ç®¡ç”¨ a,b å“ªä¸€ç¨®æ–¹æ³•, æ¬¡æ•¸éƒ½æ˜¯å…©æ¬¡

str = "cdd";

ç”¨ a (++start):
ç¬¬ä¸€æ¬¡ c != d, æ‰€ä»¥ ++start
ç¬¬äºŒæ¬¡ d == d, æ‰€ä»¥å¾—åˆ°å…©æ¬¡

ç”¨ b: (--end):
ç¬¬ä¸€æ¬¡ c != d, æ‰€ä»¥ --end
ç¬¬äºŒæ¬¡ c != d, æ‰€ä»¥å¾—åˆ°å…©æ¬¡

é ä¼°æ™‚é–“è¤‡é›œåº¦ O(n) å› ç‚ºåªéœ€è¦å¾é ­å°¾é–‹å§‹æƒåˆ°ä¸­é–“, æœ€å¤š n å€‹å­—å…ƒ

åˆ°ç›®å‰ç‚ºæ­¢ç¶“éæ™‚é–“: 8åˆ†21ç§’
é–‹å§‹å¯¦ä½œ

```c++
class Solution {
public:
    int removePalindromeSub(string s) {
        int start = 0;
        int end = s.size() - 1;
        int count = 1;
        while (start < end) {
            if (s[start] == s[end]) {
                ++start;
                --end;
                continue;
            } else {
                ++start;
                ++count;
            }
        }
        return count;
    }
};
```

ç›®å‰çš„å¯¦ä½œå°æ–¼é€™å€‹å­—ä¸²æœƒåˆ¤æ–·éŒ¯èª¤:
"baabb"
æˆ‘çš„ç¨‹å¼å¾—åˆ° 3 æ¬¡çš„çµæœ, ä½†æ­£ç¢ºæ˜¯ 2 æ¬¡

åˆ°ç›®å‰ç‚ºæ­¢ç¶“éæ™‚é–“: 11åˆ†14ç§’
é–‹å§‹ debug

count = 1;
"baabb"
b == b, ++start, --end;
a != b, ++start, ++count; (count = 2)
a != b, ++start, ++count; (count = 3)

ä½†å¯¦éš›å¯ä»¥é€™æ¨£åš, åªéœ€è¦ 2 æ¬¡:
"baabb" -> "b" -> ""

å•é¡Œåœ¨æ–¼, two pointers å³ä½¿é‡åˆ°ä¸€æ¨£çš„å­—å…ƒ, ç›´æ¥åˆªé™¤æœ‰å¯èƒ½ä¸æ˜¯æœ€ä½³è§£?

å¦ä¸€ç¨® case:
"baabbb" -> "aabb" -> "aa" -> "" (ä¸å°)
"baabbb" -> "bbbb" -> ""

åˆ°ç›®å‰ç‚ºæ­¢ç¶“éæ™‚é–“: 23åˆ†
çœ‹äº†æç¤º Hint 1:
Use the fact that string contains only 2 characters.

çªç„¶ç™¼ç¾é¡Œç›®çš„ Constraints æœ‰é€™å€‹è¦å®š s[i] is either 'a' or 'b'.
æ²’çœ‹æ¸…é¡Œç›®, é‡æ–°æƒ³è§£æ³•

è‹¥ two pointers å¾ä¸­é–“é–‹å§‹æƒï¼Ÿä¼¼ä¹æ²’å¹«åŠ©, å› ç‚ºæœ‰å¯èƒ½å­—ä¸²æ˜¯ baabbbbb

æ‰¾å‡ºå“ªä¸€ç¨®å­—ä¸²æ˜¯ 3 æ¬¡ä»¥ä¸Š?

"baabbab" -> "abb" -> "bb" -> "" (éŒ¯èª¤)
"baabbab" -> "bb" -> "" (æ­£ç¢º, å…©æ¬¡)

ä¼¼ä¹ç­”æ¡ˆåªå¯èƒ½æœ‰1æ¬¡(å®Œå…¨æ˜¯ palindrome) æˆ–2æ¬¡?

è©¦è©¦æ‰¾å…¶ä»–å­—ä¸²:
"ababab" -> "babab" -> "" (å…©æ¬¡)
"ababbb" -> "aba" -> "" (å…©æ¬¡)
"abbbba"

ä¼¼ä¹å¾ˆé›£æ‰¾åˆ° 3 æ¬¡çš„ case?

"ab", "ba"
"aaa", "aab", "abb", "aba", "bbb", "bba", "baa", "bab"

åŒ–æˆ 2 é€²åˆ¶è¡¨ç¤º

000, 001, 010, 011, 100, 101, 110, 111

æ”¾æ£„æ¨å° (æ™‚é–“ä¾†åˆ° 40 åˆ†), ç›´æ¥å¯¦ä½œ, å¦‚æœæ˜¯ palindrome å°±æ˜¯ 1 æ¬¡, å…¶ä»–ä»»ä½• case éƒ½æ˜¯ 2 æ¬¡

æœ€çµ‚ submit ç¨‹å¼ç¢¼:

```c++
class Solution {
public:
    int removePalindromeSub(string s) {
        int start = 0;
        int end = s.size() - 1;
        while (start < end) {
            if (s[start] == s[end]) {
                ++start;
                --end;
                continue;
            } else {
                return 2;
            }
        }
        return 1;
    }
};
```

submit: AC

ç¸½èŠ±è²»æ™‚é–“: 41 åˆ†
éœ€è¦ç†è§£ç‚ºä»€éº¼å…¶ä»– case éƒ½æ˜¯ 2 æ¬¡


Gemini è¬›è©•
===========

é€™é¡Œçš„é—œéµåœ¨æ–¼å…©å€‹å®šç¾©çš„çµåˆï¼š

Subsequence (å­åºåˆ—)ï¼šä¸éœ€è¦é€£çºŒï¼Œåªè¦ç›¸å°é †åºä¸è®Šå³å¯ã€‚

åªæœ‰ 'a' å’Œ 'b' å…©ç¨®å­—å…ƒã€‚

è­‰æ˜æ€è·¯ï¼š
* å¦‚æœå­—ä¸²æœ¬èº«å°±æ˜¯ Palindrome $\rightarrow$ 1 æ¬¡ (åˆªé™¤å…¨éƒ¨)ã€‚
* å¦‚æœå­—ä¸²ä¸æ˜¯ Palindromeï¼š
* å› ç‚ºå­åºåˆ—ä¸éœ€è¦é€£çºŒï¼Œæˆ‘å€‘å¯ä»¥ä¸€æ¬¡æŠŠæ‰€æœ‰çš„ 'a' éƒ½æŒ‘å‡ºä¾†åˆªæ‰ã€‚å› ç‚º 'a', 'aa', 'aaa'... å…¨éƒ¨éƒ½æ˜¯ Palindromeã€‚
* åˆªå®Œæ‰€æœ‰çš„ 'a' ä¹‹å¾Œï¼Œå‰©ä¸‹çš„åªæœƒæ˜¯ 'b'ã€‚æ‰€æœ‰çš„ 'b' çµ„æˆçš„å­—ä¸² ('b', 'bb', ...) ä¹Ÿä¸€å®šæ˜¯ Palindromeã€‚
* æ‰€ä»¥ï¼Œå…ˆåˆªæ‰€æœ‰ 'a'ï¼Œå†åˆªæ‰€æœ‰ 'b'ï¼ˆæˆ–è€…åéä¾†ï¼‰ï¼Œæœ€å¤šåªéœ€è¦ 2 æ¬¡ å°±èƒ½æ¸…ç©ºå­—ä¸²ã€‚


å»ºè­°æ”¹é€²ç­–ç•¥ï¼š

ç²¾æº–å€åˆ† Substring vs. Subsequenceï¼š

çœ‹åˆ° Subsequenceï¼Œé—œéµå­—é€šå¸¸æ˜¯ï¼šä¸é€£çºŒã€ç›¸å°é †åºã€‚

çœ‹åˆ° Substring / Subarrayï¼Œé—œéµå­—é€šå¸¸æ˜¯ï¼šé€£çºŒã€Sliding Windowã€‚

Action: ä¸‹æ¬¡çœ‹åˆ°é€™å…©å€‹å­—ï¼Œå¼·è¿«è‡ªå·±å¤§è²å”¸å‡ºä¾†ä¸¦ç¢ºèªå®šç¾©ã€‚

å¾ Constraints æ‰¾ç·šç´¢ï¼š

é€™é¡Œçš„ s[i] is 'a' or 'b' æ˜¯å·¨å¤§çš„æç¤ºã€‚å¦‚æœå­—å…ƒé›†å¾ˆå¤§ (a-z)ï¼Œé€™é¡Œå°±æ˜¯ DPï¼›å¦‚æœå­—å…ƒé›†å¾ˆå° (0/1 æˆ– a/b)ï¼Œé€šå¸¸æœ‰æ•¸å­¸æˆ–é‚è¼¯ä¸Šçš„å·§è§£ã€‚

Action: åœ¨é–‹å§‹æƒ³æ¼”ç®—æ³•ä¹‹å‰ï¼Œå…ˆçœ‹ Constraintsã€‚

ä¸è¦ç‚ºäº†ç”¨æ¼”ç®—æ³•è€Œç”¨æ¼”ç®—æ³• (Hammer and Nail æ•ˆæ‡‰)ï¼š

ä½ å› ç‚ºåœ¨ç·´ç¿’ Two Pointersï¼Œæ‰€ä»¥å¼·è¡Œå¥—ç”¨ã€‚é¢è©¦æ™‚ï¼Œå…ˆå¾ Brute Force æˆ–ç°¡å–®é‚è¼¯æƒ³ï¼Œä¸è¦é è¨­ã€Œé€™ä¸€å®šæ˜¯ç”¨æŸå€‹æ¼”ç®—æ³•ã€ã€‚

é€™é¡Œç¢ºå¯¦è¦ç”¨ Two Pointers ä¾†åˆ¤æ–·ã€Œæ˜¯å¦ç‚ºå›æ–‡ã€ï¼Œä½†å¤–å±¤é‚è¼¯æ˜¯æ•¸å­¸æ€§è³ªã€‚

Test First, Code Later (TDD æ€ç¶­)ï¼š

ä½ åœ¨ 8 åˆ†é˜æ™‚é–‹å§‹å¯« Codeï¼Œä½†å¦‚æœé‚£æ™‚å€™ä½ å…ˆç”¨ baabb åœ¨ç´™ä¸Šè·‘ä¸€éä½ çš„é‚è¼¯ï¼Œä½ å°±æœƒç™¼ç¾é‚è¼¯æ˜¯éŒ¯çš„ï¼Œå¾è€Œçœä¸‹å¯« Code çš„æ™‚é–“ã€‚

Rule: åœ¨æ²’æœ‰ç”¨ 2-3 å€‹ä¸åŒé¡å‹çš„ Test Case (åŒ…å« Edge Case) é©—è­‰éé‚è¼¯å‰ï¼Œçµ•å°ä¸è¦å¯« class Solutionã€‚

æ™‚é–“ç®¡ç†ï¼š

Easy é¡Œç›®ç›®æ¨™ï¼š10-15 åˆ†é˜è§£æ±º (å«è¬›è§£)ã€‚

Medium é¡Œç›®ç›®æ¨™ï¼š20-25 åˆ†é˜ã€‚

å¦‚æœä½ ç™¼ç¾å·²ç¶“éäº† 15 åˆ†é˜é‚„åœ¨ä¿®é‚è¼¯ï¼Œé€šå¸¸éœ€è¦è«‹æ±‚æç¤ºæˆ–æ›å€‹æ€è·¯ã€‚
